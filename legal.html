<!DOCTYPE html>
<html class="dark" lang="fr">

<head>
    <meta charset="utf-8" />
    <meta content="width=device-width, initial-scale=1.0" name="viewport" />
    <title>Politique de confidentialité & Conditions - Action Flow</title>
    <meta name="robots" content="noindex, nofollow" />
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Crect width='32' height='32' rx='6' fill='%23030303'/%3E%3Ccircle cx='16' cy='16' r='5' fill='white'/%3E%3Ccircle cx='16' cy='16' r='8' fill='none' stroke='rgba(255,255,255,0.3)' stroke-width='1'/%3E%3C/svg%3E">
    <script src="https://cdn.tailwindcss.com?plugins=forms,container-queries"></script>
    <link href="https://fonts.googleapis.com/css2?family=Plus+Jakarta+Sans:wght@400;500;600&family=Space+Grotesk:wght@500;600&display=swap" rel="stylesheet" />
    <script>
        tailwind.config = {
            darkMode: "class",
            theme: {
                extend: {
                    colors: {
                        "primary": "#ffffff",
                        "secondary": "#a1a1aa",
                        "accent": "#e4e4e7",
                        "dark-obsidian": "#030303",
                    },
                    fontFamily: {
                        "display": ["Space Grotesk", "sans-serif"],
                        "sans": ["Plus Jakarta Sans", "sans-serif"]
                    }
                },
            },
        }
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background-color: #030303;
            color: #a1a1aa;
            font-family: 'Plus Jakarta Sans', sans-serif;
            min-height: 100vh;
            line-height: 1.7;
        }

        /* ===== MESH GRADIENT BACKGROUND ===== */
        #mesh-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -2;
            opacity: 0.8;
        }

        /* ===== PARTICLE NETWORK ===== */
        #particle-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            opacity: 0.25;
        }

        /* Glass card thin - for logo */
        .glass-card-thin {
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            background: rgba(255, 255, 255, 0.02);
            border: 1px solid rgba(255, 255, 255, 0.08);
        }

        .content-section {
            background: rgba(255, 255, 255, 0.02);
            border: 1px solid rgba(255, 255, 255, 0.06);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
        }

        a {
            color: #e4e4e7;
            text-decoration: underline;
            text-underline-offset: 2px;
        }

        a:hover {
            color: #ffffff;
        }
    </style>
</head>

<body class="font-sans">
    <!-- Mesh Gradient Canvas -->
    <canvas id="mesh-canvas"></canvas>

    <!-- Particle Network Canvas -->
    <canvas id="particle-canvas"></canvas>

    <!-- Header -->
    <header class="fixed top-0 left-0 right-0 z-50 px-6 py-6">
        <nav class="flex justify-center">
            <a href="/" class="inline-flex items-center glass-card-thin px-6 py-3 rounded-2xl no-underline">
                <div class="flex items-center gap-3">
                    <div class="w-8 h-8 rounded-full border border-white/20 flex items-center justify-center">
                        <div class="w-2 h-2 bg-white rounded-full animate-pulse"></div>
                    </div>
                    <span class="text-lg font-display font-medium tracking-tight text-white">ACTION<span
                            class="opacity-40">.FLOW</span></span>
                </div>
            </a>
        </nav>
    </header>

    <!-- Main Content -->
    <main class="max-w-4xl mx-auto px-6 pt-32 pb-20 relative z-10">
        
        <!-- Page Title -->
        <div class="mb-16 text-center">
            <h1 class="text-3xl md:text-4xl font-display font-medium text-white mb-4">Informations légales</h1>
            <p class="text-secondary">Politique de confidentialité & Conditions d'utilisation</p>
        </div>

        <!-- Quick Navigation -->
        <div class="flex flex-wrap justify-center gap-4 mb-12">
            <a href="#privacy" class="px-4 py-2 rounded-full border border-white/10 text-sm hover:bg-white/5 transition-colors no-underline text-secondary hover:text-white">
                Politique de confidentialité
            </a>
            <a href="#terms" class="px-4 py-2 rounded-full border border-white/10 text-sm hover:bg-white/5 transition-colors no-underline text-secondary hover:text-white">
                Conditions d'utilisation
            </a>
        </div>

        <!-- Privacy Policy -->
        <section id="privacy" class="content-section rounded-2xl p-8 md:p-12 mb-8">
            <h2 class="text-2xl font-display font-medium text-white mb-8 flex items-center gap-3">
                <span class="w-2 h-2 bg-white rounded-full"></span>
                Politique de confidentialité
            </h2>

            <p class="mb-6">
                Cette Politique explique comment Action Flow traite les informations personnelles liées à notre programme de messagerie SMS.
            </p>

            <h3 class="text-lg font-display text-white mt-8 mb-3">Collecte & utilisation</h3>
            <p class="mb-6">
                Action Flow collecte votre numéro de téléphone et, le cas échéant, votre nom et vos préférences afin d'envoyer des messages relatifs aux services demandés (rendez-vous, suivis, confirmations) et, si vous y avez consenti, des messages promotionnels.
            </p>

            <h3 class="text-lg font-display text-white mt-8 mb-3">Partage d'informations — Dispositions obligatoires</h3>
            <ul class="list-disc list-inside space-y-3 mb-6 ml-2">
                <li>Aucune information mobile ne sera partagée avec des tiers/affiliés à des fins de marketing ou promotion.</li>
                <li>Les données d'opt-in et les consentements de l'expéditeur de messages texte ne seront pas partagés avec des tiers, à l'exception des agrégateurs et des fournisseurs des services de messagerie texte nécessaires à l'acheminement et au support du service.</li>
                <li>Si d'autres sections de cette politique évoquent un partage d'informations personnelles (par ex. prestataires de service, support client), alors toutes ces catégories excluent les données d'opt-in et les consentements liés à la messagerie texte ; ces informations ne seront pas partagées avec des tiers, à l'exception des agrégateurs et des fournisseurs de services de messagerie texte.</li>
            </ul>

            <h3 class="text-lg font-display text-white mt-8 mb-3">Base légale & consentement</h3>
            <p class="mb-6">
                Action Flow n'envoie des messages promotionnels qu'avec votre consentement explicite (p. ex., case à cocher). Vous pouvez retirer votre consentement à tout moment en textant STOP.
            </p>

            <h3 class="text-lg font-display text-white mt-8 mb-3">Vos droits</h3>
            <p class="mb-6">
                Vous pouvez demander l'accès, la correction ou la suppression de vos données en écrivant à <a href="mailto:frederick@synccrm.ca">frederick@synccrm.ca</a>.
            </p>

            <h3 class="text-lg font-display text-white mt-8 mb-3">Sécurité & conservation</h3>
            <p class="mb-6">
                Action Flow applique des mesures de sécurité raisonnables et conserve les données aussi longtemps que nécessaire pour fournir le service ou respecter nos obligations légales.
            </p>

            <h3 class="text-lg font-display text-white mt-8 mb-3">Contact</h3>
            <p>
                Courriel : <a href="mailto:frederick@synccrm.ca">frederick@synccrm.ca</a><br>
                Téléphone : <a href="tel:+14385449475">+1 438-544-9475</a>
            </p>
        </section>

        <!-- Terms of Service -->
        <section id="terms" class="content-section rounded-2xl p-8 md:p-12">
            <h2 class="text-2xl font-display font-medium text-white mb-8 flex items-center gap-3">
                <span class="w-2 h-2 bg-white rounded-full"></span>
                Conditions d'utilisation
            </h2>

            <p class="mb-6">
                <strong class="text-white">Nom du programme :</strong> Action Flow — Alertes & Mises à jour
            </p>

            <h3 class="text-lg font-display text-white mt-8 mb-3">Description</h3>
            <p class="mb-6">
                En vous inscrivant, vous acceptez de recevoir des messages liés à vos demandes de services, rappels de rendez-vous, confirmations, avis de suivi et (le cas échéant) offres promotionnelles consenties.
            </p>

            <h3 class="text-lg font-display text-white mt-8 mb-3">Désabonnement</h3>
            <p class="mb-6">
                Vous pouvez annuler le service SMS à tout moment. Textez « STOP » au numéro <a href="tel:+14385449475">438-544-9475</a>. Après « STOP », vous recevrez une confirmation et vous ne recevrez plus de messages.
            </p>

            <h3 class="text-lg font-display text-white mt-8 mb-3">Réabonnement</h3>
            <p class="mb-6">
                Pour revenir, inscrivez-vous de nouveau (p. ex., via un formulaire ou une case à cocher d'opt-in) et Action Flow reprendra l'envoi des messages.
            </p>

            <h3 class="text-lg font-display text-white mt-8 mb-3">Aide</h3>
            <p class="mb-6">
                En cas de difficulté, répondez « HELP » pour obtenir de l'aide ou contactez Action Flow à l'adresse : <a href="mailto:frederick@synccrm.ca">frederick@synccrm.ca</a> ou au <a href="tel:+14385449475">+1 438-544-9475</a>.
            </p>

            <h3 class="text-lg font-display text-white mt-8 mb-3">Opérateurs</h3>
            <p class="mb-6">
                Les opérateurs ne sont pas responsables des messages retardés ou non délivrés.
            </p>

            <h3 class="text-lg font-display text-white mt-8 mb-3">Tarification & fréquence</h3>
            <p class="mb-6">
                Des frais de messagerie et de données peuvent s'appliquer. La fréquence des messages peut varier (p. ex., messages récurrents selon vos interactions).
            </p>

            <h3 class="text-lg font-display text-white mt-8 mb-3">Confidentialité</h3>
            <p class="mb-6">
                Pour toute question liée à la vie privée, consultez notre <a href="#privacy">Politique de confidentialité</a>.
            </p>

            <h3 class="text-lg font-display text-white mt-8 mb-3">Conformité</h3>
            <p>
                Ce programme vise à respecter les normes sectorielles (p. ex., consignes CTIA/transporteurs) et les lois applicables. Évitez tout usage interdit.
            </p>
        </section>

        <!-- Back to home -->
        <div class="text-center mt-12">
            <a href="/" class="inline-flex items-center gap-2 text-secondary hover:text-white transition-colors no-underline">
                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 19l-7-7m0 0l7-7m-7 7h18"/>
                </svg>
                Retour à l'accueil
            </a>
        </div>
    </main>

    <!-- Footer -->
    <footer class="border-t border-white/5 py-8 relative z-10">
        <div class="max-w-4xl mx-auto px-6 text-center text-sm text-secondary/60">
            © 2026 Action Flow. Tous droits réservés.
        </div>
    </footer>

    <script>
        // ===== MESH GRADIENT BACKGROUND =====
        const meshCanvas = document.getElementById('mesh-canvas');
        const meshCtx = meshCanvas.getContext('2d');
        let mouseX = 0.5;
        let mouseY = 0.5;
        let targetMouseX = 0.5;
        let targetMouseY = 0.5;

        function resizeMeshCanvas() {
            meshCanvas.width = window.innerWidth;
            meshCanvas.height = window.innerHeight;
        }
        resizeMeshCanvas();
        window.addEventListener('resize', resizeMeshCanvas);

        const orbs = [
            { x: 0.15, y: 0.1, vx: 0.0001, vy: 0.00008, radius: 0.7, color: 'rgba(255, 255, 255, 0.04)' },
            { x: 0.85, y: 0.2, vx: -0.00008, vy: 0.0001, radius: 0.6, color: 'rgba(255, 255, 255, 0.03)' },
            { x: 0.5, y: 0.6, vx: 0.00008, vy: -0.00008, radius: 0.65, color: 'rgba(255, 255, 255, 0.035)' },
            { x: 0.2, y: 0.85, vx: 0.0001, vy: 0.00006, radius: 0.5, color: 'rgba(255, 255, 255, 0.03)' },
            { x: 0.7, y: 0.7, vx: -0.00006, vy: -0.0001, radius: 0.45, color: 'rgba(255, 255, 255, 0.025)' },
        ];

        document.addEventListener('mousemove', (e) => {
            targetMouseX = e.clientX / window.innerWidth;
            targetMouseY = e.clientY / window.innerHeight;
        });

        function drawMeshGradient() {
            meshCtx.fillStyle = '#030303';
            meshCtx.fillRect(0, 0, meshCanvas.width, meshCanvas.height);

            mouseX += (targetMouseX - mouseX) * 0.02;
            mouseY += (targetMouseY - mouseY) * 0.02;

            orbs.forEach((orb, i) => {
                orb.x += orb.vx + Math.sin(Date.now() * 0.0001 + i) * 0.0001;
                orb.y += orb.vy + Math.cos(Date.now() * 0.00012 + i) * 0.0001;

                const dx = mouseX - orb.x;
                const dy = mouseY - orb.y;
                orb.x += dx * 0.001;
                orb.y += dy * 0.001;

                if (orb.x < 0 || orb.x > 1) orb.vx *= -1;
                if (orb.y < 0 || orb.y > 1) orb.vy *= -1;
                orb.x = Math.max(0, Math.min(1, orb.x));
                orb.y = Math.max(0, Math.min(1, orb.y));

                const gradient = meshCtx.createRadialGradient(
                    orb.x * meshCanvas.width, orb.y * meshCanvas.height, 0,
                    orb.x * meshCanvas.width, orb.y * meshCanvas.height, orb.radius * Math.max(meshCanvas.width, meshCanvas.height)
                );
                gradient.addColorStop(0, orb.color);
                gradient.addColorStop(1, 'transparent');
                meshCtx.fillStyle = gradient;
                meshCtx.fillRect(0, 0, meshCanvas.width, meshCanvas.height);
            });

            requestAnimationFrame(drawMeshGradient);
        }
        drawMeshGradient();

        // ===== PARTICLE NETWORK =====
        const particleCanvas = document.getElementById('particle-canvas');
        const particleCtx = particleCanvas.getContext('2d');

        function resizeParticleCanvas() {
            particleCanvas.width = window.innerWidth;
            particleCanvas.height = window.innerHeight;
        }
        resizeParticleCanvas();
        window.addEventListener('resize', resizeParticleCanvas);

        const nodes = [];
        const nodeCount = 20;
        const connectionDistance = 180;
        const dataWords = ['SYNC', 'DATA', 'FLOW', 'NODE', 'HASH', 'TASK', 'LOAD', 'PIPE', 'CORE', 'FLUX'];

        class Node {
            constructor(index) {
                this.x = Math.random() * particleCanvas.width;
                this.y = Math.random() * particleCanvas.height;
                this.vx = (Math.random() - 0.5) * 0.3;
                this.vy = (Math.random() - 0.5) * 0.3;
                this.radius = 2 + Math.random() * 2;
                this.label = dataWords[index % dataWords.length];
                this.hasLabel = Math.random() > 0.6;
                this.floatOffset = Math.random() * Math.PI * 2;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.x += Math.sin(Date.now() * 0.0005 + this.floatOffset) * 0.2;
                this.y += Math.cos(Date.now() * 0.0004 + this.floatOffset) * 0.2;

                if (this.x < 50) this.vx = Math.abs(this.vx);
                if (this.x > particleCanvas.width - 50) this.vx = -Math.abs(this.vx);
                if (this.y < 50) this.vy = Math.abs(this.vy);
                if (this.y > particleCanvas.height - 50) this.vy = -Math.abs(this.vy);
            }

            draw() {
                particleCtx.beginPath();
                particleCtx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                particleCtx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                particleCtx.fill();

                particleCtx.beginPath();
                particleCtx.arc(this.x, this.y, this.radius + 2, 0, Math.PI * 2);
                particleCtx.strokeStyle = 'rgba(255, 255, 255, 0.12)';
                particleCtx.lineWidth = 1;
                particleCtx.stroke();

                if (this.hasLabel) {
                    particleCtx.font = '8px monospace';
                    particleCtx.textAlign = 'center';
                    particleCtx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                    particleCtx.fillText(this.label, this.x, this.y + this.radius + 12);
                }
            }
        }

        for (let i = 0; i < nodeCount; i++) {
            nodes.push(new Node(i));
        }

        const starDust = [];
        const starCount = 60;

        class StarParticle {
            constructor() {
                this.x = Math.random() * particleCanvas.width;
                this.y = Math.random() * particleCanvas.height;
                this.radius = 0.5 + Math.random() * 1.5;
                this.twinkle = Math.random() > 0.85;
                this.twinkleSpeed = 0.002 + Math.random() * 0.003;
                this.twinkleOffset = Math.random() * Math.PI * 2;
                this.vy = (Math.random() - 0.5) * 0.15;
            }

            update() {
                this.y += this.vy;
                if (this.y < 0) this.y = particleCanvas.height;
                if (this.y > particleCanvas.height) this.y = 0;
            }

            draw() {
                let opacity = 0.2;
                if (this.twinkle) {
                    opacity *= 0.5 + Math.sin(Date.now() * this.twinkleSpeed + this.twinkleOffset) * 0.5;
                }
                particleCtx.beginPath();
                particleCtx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                particleCtx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
                particleCtx.fill();
            }
        }

        for (let i = 0; i < starCount; i++) {
            starDust.push(new StarParticle());
        }

        function drawParticles() {
            particleCtx.clearRect(0, 0, particleCanvas.width, particleCanvas.height);

            for (let i = 0; i < nodes.length; i++) {
                for (let j = i + 1; j < nodes.length; j++) {
                    const dx = nodes[i].x - nodes[j].x;
                    const dy = nodes[i].y - nodes[j].y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < connectionDistance) {
                        const opacity = (1 - distance / connectionDistance) * 0.15;
                        particleCtx.beginPath();
                        particleCtx.moveTo(nodes[i].x, nodes[i].y);
                        particleCtx.lineTo(nodes[j].x, nodes[j].y);
                        particleCtx.strokeStyle = `rgba(255, 255, 255, ${opacity})`;
                        particleCtx.lineWidth = 0.5;
                        particleCtx.stroke();
                    }
                }
            }

            nodes.forEach(node => {
                node.update();
                node.draw();
            });

            starDust.forEach(star => {
                star.update();
                star.draw();
            });

            requestAnimationFrame(drawParticles);
        }
        drawParticles();
    </script>
</body>

</html>
